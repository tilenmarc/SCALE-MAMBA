from Compiler import ml_simple

def output_result(res):
    res.reveal_to(0)

def load_fix():
    v0 = sint.get_private_input_from(0, 0)
    v1 = sint.get_private_input_from(1, 1)
    v2 = sint.get_private_input_from(2, 2)

    v = ((v0 + v1 + v2) % 2**41)
    v = v - ((v >> 40) * 2**41)
    fx = sfix(0)
    fx.v = v

    return fx

def load_fix_array():
    a = sfix.Array(320)
    @for_range(320)
    def f(i):
        a[i] = load_fix()
    return a

def load_input_output():
    a = load_fix_array()
    X = sfix.Matrix(320 / (15 + 1), 15)
    Y = sfix.Matrix(320 / (15 + 1), 1)

    @for_range(320 / (15 + 1))
    def f(i):
        @for_range(15 + 1)
        def g(j):
            if_then(j < 15)
            X[i][j] = a[i * (15 + 1) + j]
            else_then()
            Y[i][j - 15] = a[i * (15 + 1) + j]
            end_if()

    return X, Y





X, Y = load_input_output()

# @for_range(320 / (15 + 1))
# def f(i):
#     @for_range(15)
#     def g(j):
#         print_ln('in %s', X[i][j].reveal())
#
#
# @for_range(320 / (15 + 1))
# def f(i):
#     @for_range(1)
#     def g(j):
#         print_ln('out %s', Y[i][j].reveal())


nn = ml_simple.NeuralNetwork(15, 5, 1)

print_ln('W %s %s %s %s', nn.W1[0][0].reveal(), nn.W1[0][1].reveal(), nn.W1[1][0].reveal(), nn.W1[1][1].reveal())

out = nn.forward(X[0])
print_ln('before gradient %s', out[0].reveal())
out = nn.forward(X[3])
print_ln('before gradient %s', out[0].reveal())

grad = nn.gradient_descent(X, Y, 10)

# print_ln('W %s %s %s %s', nn.W1[0][0].reveal(), nn.W1[0][1].reveal(), nn.W1[1][0].reveal(), nn.W1[1][1].reveal())
out = nn.forward(X[0])
print_ln('before gradient %s', out[0].reveal())
out = nn.forward(X[3])
print_ln('after gradient %s', out[0].reveal())


#leave this
s = sint(2)
output_result(s)
restart()

